---

# Create a CA, server and client keys with OpenSSL
- name: "First, on the Docker daemon’s host machine, generate CA private and public keys"
  command: "openssl genrsa -aes256 -out ca-key.pem 4096"
  tags: ["ssl"]
# Now that you have a CA, you can create a server key and certificate signing request (CSR). Make sure that
# “Common Name” matches the hostname you use to connect to Docker
# Note: Replace all instances of $HOST in the following example with the DNS name of your Docker daemon’s host.
- name: "First, on the Docker daemon’s host machine, generate CA private and public keys"
  command: "openssl genrsa -out server-key.pem 4096"
  tags: ["ssl"]

# Next, we’re going to sign the public key with our CA:
# Since TLS connections can be made through IP address as well as DNS name, the IP addresses need to be specified when
# creating the certificate. For example, to allow connections using 10.10.10.20 and 127.0.0.1:
- name: "sign the public key with our CA"
  command: "echo subjectAltName = DNS:$HOST,IP:10.10.10.20,IP:127.0.0.1 >> extfile.cnf"
  tags: ["ssl"]

# Set the Docker daemon key’s extended usage attributes to be used only for server authentication:
- name: "Set the Docker daemon key’s extended usage attributes to be used only for server authentication"
  command: "echo extendedKeyUsage = serverAuth >> extfile.cnf"
  tags: ["ssl"]

- name: "Now, generate the signed certificate"
  command: "openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile extfile.cnf"
  tags: ["ssl"]

# Authorization plugins offer more fine-grained control to supplement authentication from mutual TLS. In addition to
# other information described in the above document, authorization plugins running on a Docker daemon receive the
# certificate information for connecting Docker clients.
- name: "For client authentication, create a client key and certificate signing request"
  command: "openssl genrsa -out key.pem 4096"
  tags: ["ssl"]

# To make the key suitable for client authentication, create a new extensions config file
- name: "Create a new extensions config file"
  command: "echo extendedKeyUsage = clientAuth > extfile-client.cnf"
  tags: ["ssl"]

- name: "Now, generate the signed certificate"
  command: "openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out cert.pem -extfile extfile-client.cnf"
  tags: ["ssl"]

- name: "After generating cert.pem and server-cert.pem you can safely remove the two certificate signing requests and extensions config files"
  command: "rm -v client.csr server.csr extfile.cnf extfile-client.cnf"
  tags: ["ssl"]
# With a default umask of 022, your secret keys are world-readable and writable for you and your group.
# To protect your keys from accidental damage, remove their write permissions. To make them only readable by you,
# change file modes as follows
# Certificates can be world-readable, but you might want to remove write access to prevent accidental damage
- name: "Protect keys"
  become: true
  file:
    path: "{{ item }}"
    state: file
    modification_time: now
    access_time: now
    owner: root
    group: root
    mode: '0400' # '0444'
  with_items:
    - 'ca-key.pem'
    - 'key.pem'
    - 'server-key.pem'
  tags: ["ssl"]

- name: ""
  command: "dockerd --tlsverify --tlscacert=ca.pem --tlscert=server-cert.pem --tlskey=server-key.pem -H=0.0.0.0:2376"
  tags: ["docker", "daemon"]
# To connect to Docker and validate its certificate, provide your client keys, certificates and trusted CA:
# Run it on the client machine
# This step should be run on your Docker client machine. As such, you need to copy your CA certificate, your server
# certificate, and your client certificate to that machine.
# Note: Replace all instances of $HOST in the following example with the DNS name of your Docker daemon’s host.
- name: ""
  command: "docker --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=key.pem -H=$HOST:2376 version"
  tags: ["docker", "client"]
# Note: Docker over TLS should run on TCP port 2376.
# Warning: As shown in the example above, you don’t need to run the docker client with sudo or the docker group when
# you use certificate authentication. That means anyone with the keys can give any instructions to your Docker daemon,
# giving them root access to the machine hosting the daemon. Guard these keys as you would a root password!



# If you want to secure your Docker client connections by default, you can move the files to the .docker directory in
# your home directory --- and set the DOCKER_HOST and DOCKER_TLS_VERIFY variables as well (instead of passing
# -H=tcp://$HOST:2376 and --tlsverify on every call).
- name: "Ensure current user has docker group"
  when: docker_client_user_privileged is not defined
  user:
    name: "{{ lookup('env','USER') }}"
    groups: "{{ docker_group }}"
    state: state|default("present")
    append: true
    remove: true
  tags: ["docker", "client"]

- name: "Set Docker client configuration directory"
  when: docker_client_config_path is not defined and docker_client_user_privileged
  set_fact:
    docker_client_config_path: "{{ lookup('env', 'pwd') }}/.docker"
    cacheable: true
  tags: ["docker", "client"]

- name: "Set Docker client certificate path facts"
  tags: ["docker", "client"]
  set_fact:
    docker_ca_path: "{{ docker_client_config_path }}/{{ ssl_role_ca_key_file }}"
    docker_key_path: "{{ docker_client_config_path }}/{{ ssl_role_certificate_key_file }}"
    key_path: "{{ docker_client_config_path }}/{{ ssl_role_private_key_file }}"
    cacheable: true


- name: "Set docker daemon public host to hostname used by inventory"
  when: docker_daemon_public_host is not defined
  set_fact:
    docker_daemon_public_host: inventory_hostname
  tags: ["docker", "daemon"]
- debug: var=docker_daemon_public_host, verbosity=1

- name: "Set docker daemon public port to HTTPS default"
  when: docker_daemon_public_port is not defined
  set_fact:
    docker_daemon_public_port: 443
  tags: ["docker", "daemon"]
- debug: var=docker_daemon_public_port, verbosity=1

- name: "Set docker daemon host to fqdn or to listening every connection"
  when: docker_daemon_host is not defined
  set_fact:
    docker_daemon_host: docker_daemon_public_host|default('0.0.0.0')
  tags: ["docker", "daemon"]
- debug: var=docker_daemon_public_host, verbosity=1

- name: "Set docker daemon port"
  when: docker_daemon_port is not defined
  set_fact:
    docker_daemon_port: docker_daemon_public_port|default('2345')
  tags: ["docker", "daemon"]
- debug: var=daemon_port, verbosity=1

- name: "Ensure docker client directory exists"
  file:
    path: "{{ lookup('env', 'pwd') }}/.docker"
    state: directory
  tags: ["docker", "client"]

- name: "Copy certificates to docker client"
  file:
    src: "{{ item }}"
    dest: "{{ lookup('env', 'pwd') }}/.docker/{{ item }}"
    state: file
  with_items:
    - "{{ docker_ca_path }}"
    - "{{ docker_cert_path }}"
    - "{{ docker_key_path }}"
  tags: ["docker", "client"]

#- name: "Commands"
#  command: "{{ item }}"
#  with_items:
#    - "export DOCKER_TLS_VERIFY=1"
#    - "export DOCKER_HOST=tcp://{{ docker_daemon_host }}:{{ docker_daemon_port }}"
#    - "curl https://{{ docker_daemon_host }}:{{ docker_daemon_port }}/images/json" --cert {{ docker_cert_path }} --key {{ docker_key_path }} --cacert {{ docker_ca_path }}"
#  tags: ["docker", "client", "skip_ansible_lint"]
